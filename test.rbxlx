<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">InventorySystemShared</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Domain = require(script.Domain)
local Infrastructure = require(script.Infrastructure)
local Data = require(script.Data)

---@class InventorySystemShared
local Shared = {}
Shared.__index = Shared

function Shared.new()
	local self = setmetatable({}, Shared)
	self.domain = Domain.new()
	self.infrastructure = Infrastructure.new()
	self.data = Data
	return self
end

function Shared:init()
	self.infrastructure.diContainer:singleton("Shared.Infrastructure", function()
		return self.infrastructure
	end)
    
    self.infrastructure.diContainer:singleton("Shared.Domain", function()
		return self.domain
	end)

	self.infrastructure.diContainer:singleton("Shared.Data", function()
		return self.data
	end)

end

return Shared
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">Data</string>
            <string name="Source">local AmuletsList = require(script.AmuletsList)
local FruitsList = require(script.FruitsList)
local RingsList = require(script.RingsList)

local BonusIcons = {
    Energy = "rbxassetid://95399152641597",
    Damage = "rbxassetid://120524693255496",
    Gems = "rbxassetid://124904701085442",
}

---@class InventorySystemData
local Data = {
    AmuletsList = AmuletsList,
    FruitsList = FruitsList,
    RingsList = RingsList,
    BonusIcons = BonusIcons,
}

return Data</string>
          </Properties>
          <Item class="ModuleScript" referent="4">
            <Properties>
              <string name="Name">AmuletsList</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SharedModules = ReplicatedStorage.SharedModules
local AmuletsModule = require(SharedModules.Amulets)

---@class AmuletsList
local AmuletsList = {
	["Earth Stone"] = {
		icon = AmuletsModule["Earth Stone"].Icon,
		bonusType = AmuletsModule["Earth Stone"].BonusType,
		bonusValue = AmuletsModule["Earth Stone"].BonusSize,
	},
	["Fire Crystal"] = {
		icon = AmuletsModule["Fire Crystal"].Icon,
		bonusType = AmuletsModule["Fire Crystal"].BonusType,
		bonusValue = AmuletsModule["Fire Crystal"].BonusSize,
	},
	["Ice Shard"] = {
		icon = AmuletsModule["Ice Shard"].Icon,
		bonusType = AmuletsModule["Ice Shard"].BonusType,
		bonusValue = AmuletsModule["Ice Shard"].BonusSize,
	},
}

return AmuletsList
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="5">
            <Properties>
              <string name="Name">FruitsList</string>
              <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SharedModules = ReplicatedStorage.SharedModules
local FruitsModule = require(SharedModules.Fruits)

---@class FruitsList
local FruitsList = {

	["Bari Fruit"] = {
		icon = FruitsModule["Bari Fruit"].Icon,
		bonusType = FruitsModule["Bari Fruit"].BonusType,
		bonusValue = FruitsModule["Bari Fruit"].BonusSize,
	},
	["Gomu Fruit"] = {
		icon = FruitsModule["Gomu Fruit"].Icon,
		bonusType = FruitsModule["Gomu Fruit"].BonusType,
		bonusValue = FruitsModule["Gomu Fruit"].BonusSize,
	},
	["Ice Fruit"] = {
		icon = FruitsModule["Ice Fruit"].Icon,
		bonusType = FruitsModule["Ice Fruit"].BonusType,
		bonusValue = FruitsModule["Ice Fruit"].BonusSize,
	},
	["Love Fruit"] = {
		icon = FruitsModule["Love Fruit"].Icon,
		bonusType = FruitsModule["Love Fruit"].BonusType,
		bonusValue = FruitsModule["Love Fruit"].BonusSize,
	},
	["Magma Fruit"] = {
		icon = FruitsModule["Magma Fruit"].Icon,
		bonusType = FruitsModule["Magma Fruit"].BonusType,
		bonusValue = FruitsModule["Magma Fruit"].BonusSize,
	},
	["Phoenix Fruit"] = {
		icon = FruitsModule["Phoenix Fruit"].Icon,
		bonusType = FruitsModule["Phoenix Fruit"].BonusType,
		bonusValue = FruitsModule["Phoenix Fruit"].BonusSize,
	},
	["Quake Fruit"] = {
		icon = FruitsModule["Quake Fruit"].Icon,
		bonusType = FruitsModule["Quake Fruit"].BonusType,
		bonusValue = FruitsModule["Quake Fruit"].BonusSize,
	},
	["Rumble Fruit"] = {
		icon = FruitsModule["Rumble Fruit"].Icon,
		bonusType = FruitsModule["Rumble Fruit"].BonusType,
		bonusValue = FruitsModule["Rumble Fruit"].BonusSize,
	},
}

return FruitsList</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">RingsList</string>
              <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SharedModules = ReplicatedStorage.SharedModules
local RingsModule = require(SharedModules.Rings)

---@class RingsList
local RingsList = {
    ["Lightning Orb"] = {
        icon = RingsModule["Lightning Orb"].Icon,
        bonusType = RingsModule["Lightning Orb"].BonusType,
        bonusValue = RingsModule["Lightning Orb"].BonusSize,
    },
    ["Shadow Gem"] = {
        icon = RingsModule["Shadow Gem"].Icon,
        bonusType = RingsModule["Shadow Gem"].BonusType,
        bonusValue = RingsModule["Shadow Gem"].BonusSize,
    },
    ["Wind Feather"] = {
        icon = RingsModule["Wind Feather"].Icon,
        bonusType = RingsModule["Wind Feather"].BonusType,
        bonusValue = RingsModule["Wind Feather"].BonusSize,
    },
}

return RingsList</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">Domain</string>
            <string name="Source">local Entities = require(script.Entities)

---@class InventorySystemDomain
---@field entities Entities
local Domain = {}
Domain.__index = Domain

function Domain.new()
    local self = setmetatable({}, Domain)
    self.entities = Entities.new()
    return self
end

return Domain</string>
          </Properties>
          <Item class="ModuleScript" referent="8">
            <Properties>
              <string name="Name">Entities</string>
              <string name="Source"><![CDATA[---@class InventorySystemEntities
local Entities = {}

-- Импорт сущностей
local Player = require(script.Player)
local Item = require(script.Item)
local Inventory = require(script.Inventory)
local EquipmentSlot = require(script.EquipmentSlot)

---@class Entities
---@field Player PlayerEntity
---@field Item ItemEntity
---@field Inventory InventoryEntity
---@field EquipmentSlot EquipmentSlotEntity
Entities.__index = Entities

function Entities.new()
	local self = setmetatable({}, Entities)
	self.Player = Player
	self.Item = Item
	self.Inventory = Inventory
	self.EquipmentSlot = EquipmentSlot

	return self
end

return Entities
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="9">
              <Properties>
                <string name="Name">EquipmentSlot</string>
                <string name="Source"><![CDATA[---@class EquipmentSlotEntity   
---@field name string
---@field displayName string
---@field allowedItemTypes table
local EquipmentSlotEntity = {}
EquipmentSlotEntity.__index = EquipmentSlotEntity

---@enum SlotName
EquipmentSlotEntity.SlotName = {
    LEFT_HAND = "leftHand",
    RIGHT_HAND = "rightHand",
    HELMET = "helmet"
}

---@param name string
---@param displayName string
---@param allowedItemTypes table
---@return EquipmentSlotEntity
function EquipmentSlotEntity.new(name, displayName, allowedItemTypes, slotButton)
    local self = setmetatable({}, EquipmentSlotEntity)
    self.name = name
    self.displayName = displayName
    self.allowedItemTypes = allowedItemTypes or {}
    self.slotButton = slotButton
    return self
end

---@return string
function EquipmentSlotEntity:getName()
    return self.name
end

---@return string
function EquipmentSlotEntity:getDisplayName()
    return self.displayName
end

---@param itemType string
---@return boolean
function EquipmentSlotEntity:canEquipItemType(itemType)
    for _, allowedType in ipairs(self.allowedItemTypes) do
        if allowedType == itemType then
            return true
        end
    end
    return false
end

---@return table
function EquipmentSlotEntity:getAllowedItemTypes()
    return self.allowedItemTypes
end

-- Предопределенные слоты экипировки
EquipmentSlotEntity.LEFT_HAND = EquipmentSlotEntity.new(
    EquipmentSlotEntity.SlotName.LEFT_HAND,
    "Left Hand",
    {"weapon", "ring"}
)

EquipmentSlotEntity.RIGHT_HAND = EquipmentSlotEntity.new(
    EquipmentSlotEntity.SlotName.RIGHT_HAND,
    "Right Hand",
    {"weapon", "ring"}
)

EquipmentSlotEntity.HELMET = EquipmentSlotEntity.new(
    EquipmentSlotEntity.SlotName.HELMET,
    "Helmet",
    {"amulet"}
)

---@param slotName string
---@return EquipmentSlotEntity?
function EquipmentSlotEntity:getByName(slotName)
    if slotName == EquipmentSlotEntity.SlotName.LEFT_HAND then
        return EquipmentSlotEntity.LEFT_HAND
    elseif slotName == EquipmentSlotEntity.SlotName.RIGHT_HAND then
        return EquipmentSlotEntity.RIGHT_HAND
    elseif slotName == EquipmentSlotEntity.SlotName.HELMET then
        return EquipmentSlotEntity.HELMET
    end
    return nil
end

---@return table
function EquipmentSlotEntity.getAllSlots()
    return {
        EquipmentSlotEntity.RIGHT_HAND,
        EquipmentSlotEntity.LEFT_HAND,
        EquipmentSlotEntity.HELMET
    }
end

return EquipmentSlotEntity
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="10">
              <Properties>
                <string name="Name">Inventory</string>
                <string name="Source"><![CDATA[---@class InventoryEntity
---@field equippedItems table
---@field inventorySlots table
---@field maxSlots number
local InventoryEntity = {}
InventoryEntity.__index = InventoryEntity

local DEFAULT_MAX_SLOTS = 50

---@return InventoryEntity
function InventoryEntity.new()
	local self = setmetatable({}, InventoryEntity)
	self.equippedItems = {}
	self.inventorySlots = {}
	self.maxSlots = DEFAULT_MAX_SLOTS
	return self
end

---@return table
function InventoryEntity:getEquippedItems()
	return self.equippedItems
end

---@param slot EquipmentSlotEntity
---@return string?
function InventoryEntity:getEquippedItem(slot)
	return self.equippedItems[slot:getName()]
end

---@return table
function InventoryEntity:getInventorySlots()
	return self.inventorySlots
end

---@param itemId string
---@return number
function InventoryEntity:getItemCount(itemId)
	if self.inventorySlots[itemId] then
		return #self.inventorySlots[itemId]
	end
	return 0
end

---@param itemId string
---@return boolean
function InventoryEntity:hasItem(itemId)
	return self:getItemCount(itemId) > 0
end

---@param itemId string
---@param count number
---@return boolean
function InventoryEntity:addItem(itemId, count)
	if count <= 0 then
		return false
	end

	-- Проверить лимит инвентаря (количество всех слотов)
	local currentSlotsUsed = self:getTotalSlotsUsed()

	-- Проверить, не превысит ли добавление новых слотов лимит
	if currentSlotsUsed + count > self.maxSlots then
		return false -- Инвентарь полон
	end

	-- Инициализировать массив слотов для этого предмета, если его нет
	if not self.inventorySlots[itemId] then
		self.inventorySlots[itemId] = {}
	end

	-- Добавить count отдельных слотов для этого предмета
	for i = 1, count do
		local slotId = itemId .. "_" .. (#self.inventorySlots[itemId] + 1)
		table.insert(self.inventorySlots[itemId], { id = itemId, slotId = slotId })
	end

	return true
end

---@return number
function InventoryEntity:getTotalSlotsUsed()
	local totalSlots = 0
	for _, itemSlots in pairs(self.inventorySlots) do
		totalSlots = totalSlots + #itemSlots
	end
	return totalSlots
end

---@return number
function InventoryEntity:getMaxSlots()
	return self.maxSlots
end

---@return boolean
function InventoryEntity:isFull()
	return self:getTotalSlotsUsed() >= self.maxSlots
end

---@param itemId string
---@param count number
---@return boolean
function InventoryEntity:removeItem(itemId, count)
	if count <= 0 then
		return false
	end

	local itemSlots = self.inventorySlots[itemId]
	if not itemSlots or #itemSlots < count then
		return false -- Недостаточно предметов
	end

	-- Удалить count слотов с конца массива
	for i = 1, count do
		table.remove(itemSlots)
	end

	-- Если слотов не осталось, удалить запись полностью
	if #itemSlots == 0 then
		self.inventorySlots[itemId] = nil
	end

	return true
end

---@param slotId string
---@param slot EquipmentSlotEntity
---@return boolean
function InventoryEntity:equipItem(slotId, slot)
	-- Извлечь itemName из slotId (убираем "_номер")
	local itemName = string.match(slotId, "^(.+)_%d+$")
	if not itemName then
		return false
	end

	-- Проверить, есть ли предмет в инвентаре
	if not self:hasItem(itemName) then
		return false
	end

	-- Проверить, что slotId действительно существует в inventorySlots
	local slotExists = false
	if self.inventorySlots[itemName] then
		for _, slotData in ipairs(self.inventorySlots[itemName]) do
			if slotData.slotId == slotId then
				slotExists = true
				break
			end
		end
	end
	if not slotExists then
		return false
	end

	-- Снять текущий предмет из слота, если есть
	local currentEquipped = self:getEquippedItem(slot)
	if currentEquipped then
		print("InventoryEntity: Unequipping existing item", currentEquipped, "from slot", slot:getName())
		self:unequipItem(slot)
	end

	-- Экипировать новый предмет
	print("InventoryEntity: Equipping item", slotId, "in slot", slot:getName())
	self.equippedItems[slot:getName()] = slotId
	return true
end

---@param slot EquipmentSlotEntity
---@return boolean, string?
function InventoryEntity:unequipItem(slot)
	local equippedSlotId = self:getEquippedItem(slot)
	if not equippedSlotId then
		return false
	end

	-- Извлечь itemName из slotId
	local itemName = string.match(equippedSlotId, "^(.+)_%d+$")
	if not itemName then
		return false
	end

	-- Снять предмет из экипировки
	self.equippedItems[slot:getName()] = nil

	-- Вернуть предмет в инвентарь (если его там нет)
	if not self:hasItem(itemName) then
		self:addItem(itemName, 1)
	end

	return true, equippedSlotId
end

---@return table
function InventoryEntity:toDataStructure()
	return {
		equippedItems = self.equippedItems,
		inventorySlots = self.inventorySlots,
	}
end

---@param data table
---@return InventoryEntity
function InventoryEntity.fromDataStructure(data)
	local inventory = InventoryEntity.new()
	inventory.equippedItems = data.equippedItems or {}
	inventory.inventorySlots = data.inventorySlots or {}
	return inventory
end

return InventoryEntity
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="11">
              <Properties>
                <string name="Name">Item</string>
                <string name="Source"><![CDATA[---@class ItemEntity
---@field id string
---@field name string
---@field itemType string
---@field rarity string
---@field canEquip boolean
---@field equipmentSlot EquipmentSlotEntity?
---@field maxStack number
local ItemEntity = {}
ItemEntity.__index = ItemEntity

---@enum ItemType
ItemEntity.ItemType = {
	WEAPON = "weapon",
	ARMOR = "armor",
	CONSUMABLE = "consumable",
	MATERIAL = "material",
	RING = "ring",
	AMULET = "amulet",
}

---@enum ItemRarity
ItemEntity.ItemRarity = {
	COMMON = "common",
	UNCOMMON = "uncommon",
	RARE = "rare",
	EPIC = "epic",
	LEGENDARY = "legendary",
}

---@param id string
---@param name string
---@param itemType string
---@return ItemEntity
function ItemEntity.new(id, name, itemType, slotButton)
	local self = setmetatable({}, ItemEntity)
	self.id = id
	self.name = name
	self.itemType = itemType
	self.slotButton = slotButton
	return self
end

---@return string
function ItemEntity:getId()
	return self.id
end

---@return string
function ItemEntity:getName()
	return self.name
end

---@return string
function ItemEntity:getType()
	return self.itemType
end

function ItemEntity:destroy()
    
    self.slotButton:Destroy()
end

return ItemEntity
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="12">
              <Properties>
                <string name="Name">Player</string>
                <string name="Source"><![CDATA[---@class PlayerEntity
---@field id string
---@field inventory InventoryEntity
local PlayerEntity = {}
PlayerEntity.__index = PlayerEntity

---@param id string
---@param inventory InventoryEntity
---@return PlayerEntity
function PlayerEntity.new(id, inventory)
	local self = setmetatable({}, PlayerEntity)
	self.id = id
	self.inventory = inventory or {}
	self.metaPlayer = nil
	return self
end

---@return string
function PlayerEntity:getId()
	return self.id
end

---@return InventoryEntity
function PlayerEntity:getInventory()
	return self.inventory
end

---@param inventory InventoryEntity
function PlayerEntity:setInventory(inventory)
	self.inventory = inventory
end

---@param itemId string
---@param slot EquipmentSlotEntity
---@return boolean
function PlayerEntity:equipItem(itemId, slot)
	return self.inventory:equipItem(itemId, slot)
end

---@param slot EquipmentSlotEntity
---@return boolean
function PlayerEntity:unequipItem(slot)
	return self.inventory:unequipItem(slot)
end

---@param itemId string
---@param count number
---@return boolean
function PlayerEntity:addItem(itemId, count)
	return self.inventory:addItem(itemId, count)
end

---@param itemId string
---@param count number
---@return boolean
function PlayerEntity:removeItem(itemId, count)
	return self.inventory:removeItem(itemId, count)
end

---@param itemId string
---@return boolean
function PlayerEntity:hasItem(itemId)
	return self.inventory:hasItem(itemId)
end

---@param itemId string
---@return number
function PlayerEntity:getItemCount(itemId)
	return self.inventory:getItemCount(itemId)
end

function PlayerEntity:setMetaPlayer(metaPlayer)
    self.metaPlayer = metaPlayer
end
return PlayerEntity
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">Infrastructure</string>
            <string name="Source"><![CDATA[local DIContainer = require(script.DIContainer)
local Services = require(script.Services)

local RemoteEvent = script.RemoteEvent

---@class InventorySystemSharedInfrastructure
---@field remoteEvent RemoteEvent
---@field diContainer DIContainer
---@field services table
local Infrastructure = {}
Infrastructure.__index = Infrastructure

function Infrastructure.new()
    local self = setmetatable({}, Infrastructure)
    self.remoteEvent = RemoteEvent
    self.diContainer = DIContainer.new()
    self.services = Services.new(self.diContainer, self.remoteEvent)
    return self
end



return Infrastructure
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="14">
            <Properties>
              <string name="Name">DIContainer</string>
              <string name="Source"><![CDATA[---@class service
---@field factory function
---@field lifecycle string
---@field instance any

-- Простой DI Container для внедрения зависимостей
---@class DIContainer
---@field _services table<string, service>
local DIContainer = {}
DIContainer.__index = DIContainer

-- Типы жизненного цикла
DIContainer.Lifecycle = {
	SINGLETON = "singleton",
	TRANSIENT = "transient",
}

---@return DIContainer
function DIContainer.new()
	local self = setmetatable({}, DIContainer)
	self._services = {} -- name -> { factory, lifecycle, instance }
	return self
end

-- Регистрация singleton зависимости
---@param name string
---@param factory function
---@return DIContainer
function DIContainer:singleton(name, factory)
	self._services[name] = {
		factory = factory,
		lifecycle = self.Lifecycle.SINGLETON,
		instance = nil,
	}
	return self
end

-- Регистрация transient зависимости
---@param name string
---@param factory function
---@return DIContainer
function DIContainer:transient(name, factory)
	self._services[name] = {
		factory = factory,
		lifecycle = self.Lifecycle.TRANSIENT,
		instance = nil,
	}
	return self
end

-- Разрешение зависимости
---@generic T
---@param name '"InventoryRepository"' | '"ItemDefinitions"' | '"InventoryRemoteService"' | '"RemoteEventService"' | '"InventoryService"' | '"PlayerRepository"' | '"Shared.Domain"' | '"FeatureFlagService"'
---@return T
function DIContainer:resolve(name)
	local service = self._services[name]
	if not service then
		error("Service not registered: " .. name)
	end

	if service.lifecycle == self.Lifecycle.SINGLETON then
		if not service.instance then
			service.instance = service.factory(self)
		end
		return service.instance
	else
		return service.factory(self)
	end
end

-- Проверка регистрации сервиса
---@param name string
---@return boolean
function DIContainer:has(name)
	return self._services[name] ~= nil
end

-- Получение всех зарегистрированных сервисов
function DIContainer:getServices()
	local names = {}
	for name in pairs(self._services) do
		table.insert(names, name)
	end
	return names
end

return DIContainer
]]></string>
            </Properties>
          </Item>
          <Item class="RemoteEvent" referent="15">
            <Properties>
              <string name="Name">RemoteEvent</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="16">
            <Properties>
              <string name="Name">Services</string>
              <string name="Source"><![CDATA[local RemoteEventService = require(script.RemoteEventService)
local FeatureFlagService = require(script.FeatureFlagService)
local LoggerService = require(script.LoggerService)

---@class SharedInfrastructureServices
---@field remoteEvent RemoteEvent
---@field diContainer DIContainer
local Services = {}
Services.__index = Services

---@param diContainer DIContainer
---@param remoteEvent RemoteEvent
---@return SharedInfrastructureServices
function Services.new(diContainer, remoteEvent)
	local self = setmetatable({}, Services)
	self.diContainer = diContainer
	self.remoteEvent = remoteEvent
	self:_registerServices()
	return self
end

function Services:_registerServices()
	self.diContainer:singleton("RemoteEventService", function(container)
		local logger = container:resolve("Logger")
		return RemoteEventService.new(self.remoteEvent, logger)
	end)

	-- Регистрируем LoggerService
	self.diContainer:singleton("Logger", function()
		return LoggerService.new(LoggerService.LEVELS.INFO)
	end)

	-- Регистрируем FeatureFlagService с зависимостью от констант
	self.diContainer:singleton("FeatureFlagService", function()
		local constants = self.diContainer:resolve("Constants")
		return FeatureFlagService.new(constants.FeatureFlags)
	end)

end

return Services
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="17">
              <Properties>
                <string name="Name">FeatureFlagService</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

---@class FeatureFlagService
---@field _flags table<string, boolean> Текущие значения флагов
---@field _defaultFlags table<string, boolean> Значения по умолчанию
---@field _isServer boolean
local FeatureFlagService = {}
FeatureFlagService.__index = FeatureFlagService

---@param defaultFlags table<string, boolean>
---@return FeatureFlagService
function FeatureFlagService.new(defaultFlags)
	local self = setmetatable({}, FeatureFlagService)
	self._isServer = RunService:IsServer()
	self._defaultFlags = defaultFlags or {}
	self._flags = {}

	-- Копируем значения по умолчанию
	for flagName, value in pairs(self._defaultFlags) do
		self._flags[flagName] = value
	end

	return self
end

---@param flagName string
---@return boolean
function FeatureFlagService:isEnabled(flagName)
	return self._flags[flagName] == true
end

---@param flagName string
---@param enabled boolean
function FeatureFlagService:setFlag(flagName, enabled)
	if not self._isServer then
		return
	end

	self._flags[flagName] = enabled
end

---@param flagName string
---@return boolean
function FeatureFlagService:getDefaultValue(flagName)
	return self._defaultFlags[flagName] or false
end

---Сбросить флаг к значению по умолчанию
---@param flagName string
function FeatureFlagService:resetFlag(flagName)
	if not self._isServer then
		return
	end

	self._flags[flagName] = self._defaultFlags[flagName]
end

---Получить все активные флаги
---@return table<string, boolean>
function FeatureFlagService:getAllFlags()
	return table.clone(self._flags)
end

---Получить флаги для клиента (только включенные)
---@return table<string, boolean>
function FeatureFlagService:getClientFlags()
	local result = {}
	for flagName, value in pairs(self._flags) do
		if value then
			result[flagName] = true
		end
	end
	return result
end

return FeatureFlagService
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="18">
              <Properties>
                <string name="Name">LoggerService</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

---@class LoggerService
---@field _logLevel number Текущий уровень логирования
---@field _isServer boolean
---@field _blockedServices table Список заблокированных сервисов
---@field LEVELS table Уровни логирования
local LoggerService = {}
LoggerService.__index = LoggerService

-- Уровни логирования
LoggerService.LEVELS = {
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4
}

-- Префиксы для разных уровней
local LEVEL_PREFIXES = {
    [LoggerService.LEVELS.DEBUG] = "[DEBUG]",
    [LoggerService.LEVELS.INFO] = "[INFO]",
    [LoggerService.LEVELS.WARN] = "[WARN]",
    [LoggerService.LEVELS.ERROR] = "[ERROR]"
}

---@param logLevel number?
---@return LoggerService
function LoggerService.new(logLevel)
    local self = setmetatable({}, LoggerService)
    self._isServer = RunService:IsServer()
    self._blockedServices = {
        -- MineEntity = true,
        GateMultiplierDisplayService = true,
        -- LaserService = true,
        -- BoundaryService = true,
        -- ChargeZoneService = true,
        -- MineService = true,
        ClubService = true,
        AssetService = true,
        -- EffectService = true,
        -- DamageService = true,  -- Добавлено: информативные логи о повреждениях
        -- PVEService = true,  -- Оставлен для логов PVE
        PlayerEventRouter = true,
        -- GameManager = true,
        -- TeamFactory = true,
        -- PuckFactory = true,  -- Добавлено: информативные логи о создании шайб
        -- SpaceHockey = true,
        -- FlyingService = true,
        -- ShootService = true,  -- Оставлен для логов стрельбы
        -- HitscanService = true,  -- Добавлено: информативные логи о попаданиях
        -- AssetLoaderService = true,
        -- SoundEffectService = true,
        -- SoundService = true,
        -- EnergyService = true,
        -- AnimationService = true,
        -- CameraService = true,
        -- MainUI = true,
        -- EffectsUI = true,
        -- UI = true,
        -- Presentation = true,
        PlayerRepository = true,
        -- ScoreService = true,
        -- PlayerService = true,  -- Оставлен для логов игроков
        -- GateService = true,
        -- MatchService = true,
        PlayerLifecycleService = true,
        -- LobbyService = true,  -- Добавлено: информативные логи о лобби
        -- TeamService = true,
        -- ShopService = true,  -- Оставлен для логов магазина
        -- TeamBalanceService = true,
        -- DroppedPuckService = true,  -- Добавлено: информативные логи о дропе шайб
        -- PlayerRatingService = true,
        -- ClubsLeaderboardDisplayService = true,
        -- PlayersLeaderboardDisplayService = true,
        -- RemoteEventService = true,
        -- InputService = true,
        -- ShopPromptHandler = true,
        -- PlayerJoinTeamUseCase = true,
        -- PlayerPuckVisualService = true,
        PlayerEquipmentService = true,
        -- Player = true,
        -- PlayerEntity = true,
        -- PuckBoxService = true,
        -- CollectiblePuckService = true,
        -- PuckSpawnService = true,  -- Оставлен для логов спавна шайб
        -- PuckBoxEntity = true,
        -- LeaderboardService = true,  -- Оставлен для логов лидербордов
        ClubLeaderboardService = true,
        ClubRepository = true,
        -- GameService = true,  -- Оставлен для логов игры
    } -- Блокировка verbose сервисов для очистки логов

    -- На сервере и клиенте по умолчанию INFO для отображения основных логов работы систем
    self._logLevel = logLevel or self.LEVELS.INFO

    return self
end

---@param level number
function LoggerService:setLogLevel(level)
    self._logLevel = level
end

---@param level number
---@param serviceName string?
---@return boolean
function LoggerService:_shouldLog(level, serviceName)
    if level < self._logLevel then
        return false
    end

    if serviceName and self._blockedServices[serviceName] then
        return false
    end

    return true
end

---@param serviceName string
---@return boolean
function LoggerService:isServiceBlocked(serviceName)
    return self._blockedServices[serviceName] == true
end

---@param level number
---@param serviceName string
---@param message string
---@vararg any
function LoggerService:_log(level, serviceName, message, ...)
    if not self:_shouldLog(level, serviceName) then
        return
    end

    local prefix = LEVEL_PREFIXES[level] or "[UNKNOWN]"
    local timestamp = os.date("%H:%M:%S")

    local fullMessage
    if serviceName then
        fullMessage = string.format("[%s] %s [%s] %s", timestamp, prefix, serviceName, message)
    else
        fullMessage = string.format("[%s] %s %s", timestamp, prefix, message)
    end

    -- Добавляем дополнительные аргументы
    if ... then
        local args = {...}
        for _, arg in ipairs(args) do
            fullMessage = fullMessage .. " " .. tostring(arg)
        end
    end

    -- Используем соответствующую функцию Roblox
    if level == self.LEVELS.ERROR or level == self.LEVELS.WARN then
        warn(fullMessage)
    else
        print(fullMessage)
    end
end

---@param serviceName string
---@param message string
---@vararg any
function LoggerService:debug(serviceName, message, ...)
    self:_log(self.LEVELS.DEBUG, serviceName, message, ...)
end

---@param serviceName string
---@param message string
---@vararg any
function LoggerService:info(serviceName, message, ...)
    self:_log(self.LEVELS.INFO, serviceName, message, ...)
end

---@param serviceName string
---@param message string
---@vararg any
function LoggerService:warn(serviceName, message, ...)
    self:_log(self.LEVELS.WARN, serviceName, message, ...)
end

---@param serviceName string
---@param message string
---@vararg any
function LoggerService:error(serviceName, message, ...)
    self:_log(self.LEVELS.ERROR, serviceName, message, ...)
end

return LoggerService
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="19">
              <Properties>
                <string name="Name">RemoteEventService</string>
                <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
---@class RemoteEventService : IRemoteEventService
---@field _connections table<string, RBXScriptConnection>
---@field remoteEvent RemoteEvent
local RemoteEventService = {}
RemoteEventService.__index = RemoteEventService

---@param remoteEvent RemoteEvent
---@param logger LoggerService
---@return RemoteEventService
function RemoteEventService.new(remoteEvent, logger)
	local self = setmetatable({}, RemoteEventService)
	self._isServer = RunService:IsServer()
	self.remoteEvent = remoteEvent
	self._connections = {}
	self.logger = logger

	return self
end

---@param event string
---@param callback fun(...) -> ()
function RemoteEventService:connectToEvent(event, callback)
	self.logger:debug("RemoteEventService", "Connecting to event:", event)
	if self._isServer then
		self._connections[event] = self.remoteEvent.OnServerEvent:Connect(function(player, _event, args)
			if event == _event then
				self.logger:debug("RemoteEventService", "Received server event:", event, "from player:", player.Name)
				callback(player, args)
			end
		end)
	else
		self._connections[event] = self.remoteEvent.OnClientEvent:Connect(function(_event, args)
			if event == _event then
				self.logger:debug("RemoteEventService", "Received client event:", event)
				callback(args)
			end
		end)
	end
end

---@param event string
function RemoteEventService:disconnectFromEvent(event)
	self._connections[event]:Disconnect()
	self._connections[event] = nil
end

---@param event string
---@param args any[]
function RemoteEventService:fireServer(event, args)
	self.logger:debug("RemoteEventService", "Firing server event:", event)
	self.remoteEvent:FireServer(event, args)
end

---@param event string
---@param player Player
---@param args any[]
function RemoteEventService:fireClient(player, event, args)
	self.logger:debug("RemoteEventService", "Firing client event:", event, "to player:", player.Name)
	self.remoteEvent:FireClient(player, event, args)
end

---@param event string
---@param args any[]
function RemoteEventService:fireAll(event, args)
	self.logger:debug("RemoteEventService", "Firing event to all clients:", event)
	self.remoteEvent:FireAllClients(event, args)
end

return RemoteEventService
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="20">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="ModuleScript" referent="21">
      <Properties>
        <string name="Name">MetaService</string>
      </Properties>
      <Item class="Folder" referent="22">
        <Properties>
          <string name="Name">Server</string>
        </Properties>
        <Item class="ModuleScript" referent="23">
          <Properties>
            <string name="Name">InventorySystemServer</string>
            <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Shared = require(ReplicatedStorage.Shared.InventorySystemShared)
local ServerInfrastructureRepositories = require(script.Infrastructure.Repositories)
local ServerInfrastructureServices = require(script.Infrastructure.Services)
---@class InventorySystemServer
local Server = {}
Server.__index = Server

function Server.new()
	local self = setmetatable({}, Server)
	self.shared = Shared.new()
	self.services = ServerInfrastructureServices.new(self.shared.infrastructure.diContainer)
	self.repositories = ServerInfrastructureRepositories.new(self.shared.infrastructure.diContainer)
	return self
end

function Server:init()
	self.shared:init()
	-- Инициализация репозиториев
	self.repositories:init()

	-- Инициализация сервисов
	self.services:init()
end

local server = Server.new()
server:init()

return Server
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="24">
            <Properties>
              <string name="Name">Infrastructure</string>
              <string name="Source">local Repositories = require(script.Repositories)
local Services = require(script.Services)

---@class ServerInventorySystemInfrastructure
local Infrastructure = {}
Infrastructure.__index = Infrastructure

---@param diContainer DIContainer
function Infrastructure.new(diContainer)
	local self = setmetatable({}, Infrastructure)
	self.diContainer = diContainer
	self.repositories = Repositories.new(diContainer)
	self.services = Services.new(diContainer)
	return self
end

function Infrastructure:init()
    self.services:init()
end

return Infrastructure</string>
            </Properties>
            <Item class="ModuleScript" referent="25">
              <Properties>
                <string name="Name">Repositories</string>
                <string name="Source"><![CDATA[local DataStorePlayerRepository = require(script.DataStorePlayerRepository)
local InventoryRepository = require(script.InventoryRepository)

---@class ServerInfrastructureRepositories
---@field diContainer DIContainer
local ServerInfrastructureRepositories = {}
ServerInfrastructureRepositories.__index = ServerInfrastructureRepositories

---@param diContainer DIContainer
---@return ServerInfrastructureRepositories
function ServerInfrastructureRepositories.new(diContainer)
	local self = setmetatable({}, ServerInfrastructureRepositories)
	self.diContainer = diContainer
	return self
end

function ServerInfrastructureRepositories:init()
	
	-- Регистрация InventoryRepository
	self.diContainer:singleton("InventoryRepository", function(container)
		local logger = container:resolve("Logger")

		---@type InventorySystemDomain
		local domain = container:resolve("Shared.Domain")

		local InventoryEntity = domain.entities.Inventory
		local amuletsList = container:resolve("Shared.Data").AmuletsList
		local fruitsList = container:resolve("Shared.Data").FruitsList
		local ringsList = container:resolve("Shared.Data").RingsList
		return InventoryRepository.new(logger, InventoryEntity, amuletsList, fruitsList, ringsList)
	end)

	self.diContainer:singleton("PlayerRepository", function(container)
		--@type InventorySystemDomain
		local domain = container:resolve("Shared.Domain")

		local inventoryRepository = container:resolve("InventoryRepository")
		local PlayerEntity = domain.entities.Player
		local playerRepository = DataStorePlayerRepository.new(PlayerEntity, inventoryRepository)
		-- Очистка кэша при выходе игрока
		---@param player Player
		game.Players.PlayerRemoving:Connect(function(player)
			playerRepository:clearCache(tostring(player.UserId))
		end)

		return playerRepository
	end)
end

return ServerInfrastructureRepositories
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="26">
                <Properties>
                  <string name="Name">DataStorePlayerRepository</string>
                  <string name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")
local MetaService = require(ServerScriptService.MetaService)
local Players = game:GetService("Players")

---@class DataStorePlayerRepository
---@field inventoryRepository InventoryRepository
---@field _cache table<string, PlayerEntity>
---@field PlayerEntity PlayerEntity
local DataStorePlayerRepository = {}
DataStorePlayerRepository.__index = DataStorePlayerRepository

---@param PlayerEntity PlayerEntity
---@param inventoryRepository InventoryRepository
---@return DataStorePlayerRepository
function DataStorePlayerRepository.new(PlayerEntity, inventoryRepository)
	local self = setmetatable({}, DataStorePlayerRepository)
	self.PlayerEntity = PlayerEntity
	self.inventoryRepository = inventoryRepository
	self._cache = {}
	return self
end

---@param userId string
---@return PlayerEntity?
function DataStorePlayerRepository:getById(userId)
	-- Проверить кэш
	if self._cache[userId] then
		return self._cache[userId]
	end

	-- Получить объект игрока из MetaService
	local playerInstance = Players:GetPlayerByUserId(tonumber(userId))
	if not playerInstance then
		return nil
	end

	local metaPlayer = MetaService.Class.Player:Get(playerInstance)
	if not metaPlayer then
		return nil
	end

	-- Создать объект PlayerEntity на основе данных MetaService
	local playerEntity = self.PlayerEntity.new(userId)

	-- Загрузить инвентарь
	local inventory = self.inventoryRepository:getByPlayerId(userId)
	if inventory then
		playerEntity:setInventory(inventory)
	end
	-- Установить ссылку на metaPlayer для доступа к данным MetaService
	playerEntity:setMetaPlayer(metaPlayer)

	-- Добавить в кэш
	self._cache[userId] = playerEntity

	return playerEntity
end

---@param playerEntity PlayerEntity
function DataStorePlayerRepository:save(playerEntity)
	-- Добавить в кэш
	self._cache[playerEntity.userId] = playerEntity

	-- Сохранить в MetaService
	local playerInstance = Players:GetPlayerByUserId(tonumber(playerEntity.userId))
	if not playerInstance then
		return
	end

	local metaPlayer = MetaService.Class.Player:Get(playerInstance)
	if not metaPlayer then
		return
	end

	-- Сохранить инвентарь
	if playerEntity:getInventory() then
		self.inventoryRepository:save(playerEntity.userId, playerEntity:getInventory())
	end

	-- MetaService автоматически сохранит изменения
end

---@param userId string
function DataStorePlayerRepository:delete(userId)
	-- Удалить из кэша
	self._cache[userId] = nil

	-- Очистить данные в MetaService
	local playerInstance = Players:GetPlayerByUserId(tonumber(userId))
	if not playerInstance then
		return
	end

	local metaPlayer = MetaService.Class.Player:Get(playerInstance)
	if not metaPlayer then
		return
	end

	-- Очистить данные BattlepassShop
	metaPlayer.Data.BattlepassShop = nil
end

---@param userId string
function DataStorePlayerRepository:clearCache(userId)
	self._cache[userId] = nil
	self.inventoryRepository:clearCache(userId)
end

---@param userId string
---@return boolean
function DataStorePlayerRepository:exists(userId)
	local player = self:getById(userId)
	return player ~= nil
end

return DataStorePlayerRepository
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="27">
                <Properties>
                  <string name="Name">InventoryRepository</string>
                  <string name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")
local MetaService = require(ServerScriptService.MetaService)
local Players = game:GetService("Players")

---@class InventoryRepository
---@field logger Logger
---@field _cache table<string, InventoryEntity>
---@field InventoryEntity InventoryEntity
---@field amuletsList table<string, string>
---@field fruitsList table<string, string>
---@field ringsList table<string, string>
local InventoryRepository = {}
InventoryRepository.__index = InventoryRepository

---@param logger Logger
---@param InventoryEntity InventoryEntity
---@param amuletsList table<string, string>
---@param fruitsList table<string, string>
---@param ringsList table<string, string>
---@return InventoryRepository
function InventoryRepository.new(logger, InventoryEntity, amuletsList, fruitsList, ringsList)
	local self = setmetatable({}, InventoryRepository)
	self.logger = logger
	self.InventoryEntity = InventoryEntity
	self.amuletsList = amuletsList or {}
	self.fruitsList = fruitsList or {}
	self.ringsList = ringsList or {}
	self._cache = {}
	return self
end

---@param userId string
---@return any?
function InventoryRepository:_getMetaPlayer(userId)
	local playerInstance = Players:GetPlayerByUserId(tonumber(userId))
	if not playerInstance then
		return nil
	end

	local metaPlayer = MetaService.Class.Player:Get(playerInstance)
	return metaPlayer
end

---@param value any
---@return number
function InventoryRepository:_validateNumber(value)
	if type(value) == "number" then
		return value
	elseif type(value) == "boolean" then
		return value and 1 or 0
	else
		return 0
	end
end

---@param item table
---@return string?
function InventoryRepository:_getSlotNameForItem(item)
	local itemType = self:_getItemType(item.name)
	if itemType == "ring" then
		-- Для колец используем правую руку по умолчанию (как в клиенте)
		self.logger:debug("InventoryRepository", "Assigning rightHand slot for ring item:", item.name)
		return "rightHand"
	elseif itemType == "amulet" then
		-- Для амулетов используем шлем
		self.logger:debug("InventoryRepository", "Assigning helmet slot for amulet item:", item.name)
		return "helmet"
	else
		self.logger:debug("InventoryRepository", "No slot assigned for item:", item.name, "type:", itemType)
		return nil -- Для фруктов и других предметов слоты могут не быть нужны
	end
end

---@param itemName string
---@return string
function InventoryRepository:_getItemType(itemName)
	if self:checkIsAmulet(itemName) then
		return "amulet"
	elseif self:checkIsFruit(itemName) then
		return "fruit"
	elseif self:checkIsRing(itemName) then
		return "ring"
	else
		return "unknown"
	end
end

---@param accessories table
---@param itemName string
---@param instanceIndex number
---@return table?
function InventoryRepository:_findExistingItem(accessories, itemName, instanceIndex)
	local count = 0
	for _, item in ipairs(accessories) do
		if item.name == itemName then
			count = count + 1
			if count == instanceIndex then
				return item
			end
		end
	end
	return nil
end

---@param userId string
---@param itemName string
---@param action string
function InventoryRepository:_handleEquippedItemLogic(userId, itemName, action)
	if not itemName then
		return
	end

	local metaPlayer = self:_getMetaPlayer(userId)
	if not metaPlayer then
		return
	end

	local accessories = metaPlayer.Data.Inventory.Accessories
	if not accessories or type(accessories) ~= "table" then
		return
	end

	-- Проверить, что предмет может быть экипирован (кольцо или амулет)
	local isEquipable = self:checkItemType("ring", itemName) or self:checkItemType("amulet", itemName)
	if not isEquipable then
		return
	end

	-- Найти первый предмет с данным именем и установить/снять флаг equipped
	for _, item in ipairs(accessories) do
		if item.name == itemName then
			item.equipped = (action == "add")
			break -- Меняем только первый найденный предмет
		end
	end
end

---@param itemType string
---@param itemName string
---@return boolean
function InventoryRepository:checkItemType(itemType, itemName)
	local typeLists = {
		amulet = self.amuletsList,
		fruit = self.fruitsList,
		ring = self.ringsList
	}
	return typeLists[itemType] and typeLists[itemType][itemName] ~= nil
end

---@param itemName string
---@return boolean
function InventoryRepository:checkIsAmulet(itemName)
	return self:checkItemType("amulet", itemName)
end

---@param itemName string
---@return boolean
function InventoryRepository:checkIsFruit(itemName)
	return self:checkItemType("fruit", itemName)
end

---@param itemName string
---@return boolean
function InventoryRepository:checkIsRing(itemName)
	return self:checkItemType("ring", itemName)
end

---@param userId string
---@return InventoryEntity?
function InventoryRepository:getByPlayerId(userId)
	-- Проверить кэш
	-- if self._cache[userId] then
	-- 	return self._cache[userId]
	-- end

	local metaPlayer = self:_getMetaPlayer(userId)
	if not metaPlayer then
		return nil
	end

	-- Получить данные инвентаря
	local accessoriesData = metaPlayer.Data.Inventory.Accessories
	if not accessoriesData or type(accessoriesData) ~= "table" then
		return nil
	end

	-- Создать объект Inventory из данных
	-- Преобразовать массив предметов в inventorySlots и equippedItems

	local inventorySlots = {}
	local equippedItems = {}

	-- Группировать предметы по имени для подсчета количества
	local itemCounts = {}

	for _, item in ipairs(accessoriesData) do
		-- Все предметы в массиве принадлежат игроку
		itemCounts[item.name] = (itemCounts[item.name] or 0) + 1
		if item.equipped then
			-- Использовать сохраненный slotId или slotName
			local slotName = item.slotName or self:_getSlotNameForItem(item)
			if slotName then
				if item.slotId then
					-- У нас есть конкретный slotId
					equippedItems[slotName] = item.slotId
					self.logger:debug("InventoryRepository", "Loading equipped item:", item.name, "slotId:", item.slotId, "in slot:", slotName)
				else
					-- Fallback: определить slotId на основе типа предмета
					equippedItems[slotName] = item.name .. "_1"
					self.logger:debug("InventoryRepository", "Loading equipped item (fallback):", item.name, "in slot:", slotName, "slotId:", item.name .. "_1")
				end
			end
		end

		-- Создать inventorySlots на основе подсчитанных предметов
		for itemName, count in pairs(itemCounts) do
			local validatedCount = self:_validateNumber(count)
			if validatedCount > 0 then
				inventorySlots[itemName] = {}
				for i = 1, validatedCount do
					local slotId = itemName .. "_" .. i
					table.insert(inventorySlots[itemName], { id = itemName, slotId = slotId })
				end
			end
		end
	end

	local inventory = self.InventoryEntity.fromDataStructure({
		equippedItems = equippedItems,
		inventorySlots = inventorySlots,
	})

	-- Добавить в кэш
	-- self._cache[userId] = inventory

	return inventory
end

---@param userId string
---@param inventory InventoryEntity
function InventoryRepository:save(userId, inventory)
	-- Обновить кэш
	self._cache[userId] = inventory

	local metaPlayer = self:_getMetaPlayer(userId)
	if not metaPlayer then
		return
	end

	-- Получить текущий массив предметов или создать новый
	local currentAccessories = metaPlayer.Data.Inventory.Accessories
	if not currentAccessories or type(currentAccessories) ~= "table" then
		currentAccessories = {}
	end

	local data = inventory:toDataStructure()

	-- Создать словарь equipped предметов для быстрого поиска (по slotId)
	local equippedItemsMap = {}
	for slotName, slotId in pairs(data.equippedItems) do
		equippedItemsMap[slotId] = {
			slotName = slotName,
			slotId = slotId
		}
		self.logger:debug("InventoryRepository", "Preparing to save equipped item:", slotId, "in slot:", slotName)
	end

	-- Создать словарь предметов в инвентаре с их количеством
	local inventoryItemsMap = {}
	for itemName, itemSlots in pairs(data.inventorySlots) do
		local count = self:_validateNumber(#itemSlots)
		if count > 0 then
			inventoryItemsMap[itemName] = count
		end
	end

	-- Обновить массив Accessories
	local newAccessories = {}

	-- Добавить предметы из инвентаря
	for itemName, count in pairs(inventoryItemsMap) do
		local itemType = self:_getItemType(itemName)

		-- Для каждого экземпляра предмета добавить отдельный элемент
		for i = 1, count do
			local slotId = itemName .. "_" .. i
			local equippedInfo = equippedItemsMap[slotId]
			local isEquipped = equippedInfo ~= nil

			local itemData = {
				name = itemName,
				type = itemType,
				equipped = isEquipped
			}

			-- Добавить slotName и slotId для экипированных предметов
			if isEquipped then
				itemData.slotName = equippedInfo.slotName
				itemData.slotId = equippedInfo.slotId
				self.logger:debug("InventoryRepository", "Saving equipped item:", itemName, "slotId:", slotId, "slotName:", equippedInfo.slotName)
			end

			-- Добавить level если есть в существующих данных
			local existingItem = self:_findExistingItem(currentAccessories, itemName, i)
			if existingItem and existingItem.level then
				itemData.level = existingItem.level
			end

			table.insert(newAccessories, itemData)
		end
	end

	-- Сохранить обновленный массив
	metaPlayer.Data.Inventory.Accessories = newAccessories
end

---@param userId string
---@param itemId string
---@param count number
---@return boolean
function InventoryRepository:addItemToPlayer(userId, itemId, count)
	if count <= 0 then
		return false
	end

	local inventory = self:getByPlayerId(userId)
	if not inventory then
		return false
	end

	local success = inventory:addItem(itemId, count)
	if success then
		self:save(userId, inventory)
	end

	return success
end

---@param userId string
---@param itemId string
---@param count number
---@return boolean
function InventoryRepository:removeItemFromPlayer(userId, itemId, count)
	if count <= 0 then
		return false
	end

	local inventory = self:getByPlayerId(userId)
	if not inventory then
		return false
	end

	local success = inventory:removeItem(itemId, count)
	if success then
		self:save(userId, inventory)
	end

	return success
end

---@param userId string
---@param slotId string
---@param slot EquipmentSlotEntity
---@return boolean
function InventoryRepository:equipItem(userId, slotId, slot)
	local inventory = self:getByPlayerId(userId)
	if not inventory then
		return false
	end

	local success = inventory:equipItem(slotId, slot)
	if success then
		self.logger:info("InventoryRepository", "Equipping item", slotId, "in slot", slot:getName(), "- saving inventory")
		self:save(userId, inventory)

		-- Извлечь itemName из slotId для дополнительной логики
		local itemName = string.match(slotId, "^(.+)_%d+$")
		self:_handleEquippedItemLogic(userId, itemName, "add")

		-- Проверить, что данные сохранены
		local savedInventory = self:getByPlayerId(userId)
		local equippedItem = savedInventory:getEquippedItem(slot)
		self.logger:info("InventoryRepository", "Verification: equipped item in slot", slot:getName(), "is", equippedItem or "none")
	else
		self.logger:error("InventoryRepository", "Failed to equip item in inventory entity")
	end

	return success
end

---@param userId string
---@param slot EquipmentSlotEntity
---@return boolean, string?
function InventoryRepository:unequipItem(userId, slot)
	local inventory = self:getByPlayerId(userId)
	if not inventory then
		return false
	end

	local success, unequippedSlotId = inventory:unequipItem(slot)
	if success then
		self:save(userId, inventory)

		-- Извлечь itemName из unequippedSlotId для дополнительной логики
		local unequippedItemName = unequippedSlotId and string.match(unequippedSlotId, "^(.+)_%d+$")
		self:_handleEquippedItemLogic(userId, unequippedItemName, "remove")
	end

	return success, unequippedSlotId
end

---@param userId string
function InventoryRepository:clearCache(userId)
	self._cache[userId] = nil
end

return InventoryRepository

]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="28">
              <Properties>
                <string name="Name">Services</string>
                <string name="Source"><![CDATA[local InventoryService = require(script.InventoryService)
local InventoryRemoteService = require(script.InventoryRemoteService)

---@class ServerInventorySystemServices
local Services = {}
Services.__index = Services

---@param diContainer DIContainer
---@return ServerInventorySystemServices
function Services.new(diContainer)
	local self = setmetatable({}, Services)
	self.diContainer = diContainer
	self:_registerServices()
	return self
end

function Services:_registerServices()
	-- Регистрация InventoryService
	self.diContainer:singleton("InventoryService", function(container)
		local logger = container:resolve("Logger")
		local inventoryRepository = container:resolve("InventoryRepository")
		local amuletsList = container:resolve("Shared.Data").AmuletsList
		local ringsList = container:resolve("Shared.Data").RingsList
		local fruitsList = container:resolve("Shared.Data").FruitsList
		local equipmentSlot = container:resolve("Shared.Domain").entities.EquipmentSlot
		return InventoryService.new(logger, inventoryRepository, amuletsList, ringsList, fruitsList, equipmentSlot)
	end)

	-- Регистрация InventoryRemoteService
	self.diContainer:singleton("InventoryRemoteService", function(container)
		local remoteEventService = container:resolve("RemoteEventService")
		local inventoryService = container:resolve("InventoryService")
		local logger = container:resolve("Logger")
		return InventoryRemoteService.new(remoteEventService, inventoryService, logger)
	end)
end

function Services:init()
	local inventoryRemoteService = self.diContainer:resolve("InventoryRemoteService")

	inventoryRemoteService:init()
end

return Services
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="29">
                <Properties>
                  <string name="Name">InventoryRemoteService</string>
                  <string name="Source"><![CDATA[---@class InventoryRemoteService
---@field remoteEventService RemoteEventService
---@field inventoryService InventoryService
---@field logger Logger
local InventoryRemoteService = {}
InventoryRemoteService.__index = InventoryRemoteService

---@param remoteEventService RemoteEventService
---@param inventoryService InventoryService
---@param logger Logger
---@return InventoryRemoteService
function InventoryRemoteService.new(remoteEventService, inventoryService, logger)
    local self = setmetatable({}, InventoryRemoteService)
    self.remoteEventService = remoteEventService
    self.inventoryService = inventoryService
    self.logger = logger

    self:setupEventHandlers()
    return self
end

function InventoryRemoteService:init()
    -- Явная инициализация сервиса (если нужно)
end

function InventoryRemoteService:setupEventHandlers()
    -- Получение инвентаря
    self.remoteEventService:connectToEvent("GetInventory", function(player, _args)
        self:handleGetInventory(player)
    end)

    -- Добавление предмета
    self.remoteEventService:connectToEvent("AddItem", function(player, args)
        self:handleAddItem(player, args)
    end)

    -- Удаление предмета
    self.remoteEventService:connectToEvent("RemoveItem", function(player, args)
        self:handleRemoveItem(player, args)
    end)

    -- Экипировка предмета
    self.remoteEventService:connectToEvent("EquipItem", function(player, args)
        self:handleEquipItem(player, args)
    end)

	-- Снятие предмета
    self.remoteEventService:connectToEvent("UnequipItem", function(player, args)
        self:handleUnequipItem(player, args)
    end)

    -- Сброс инвентаря
    self.remoteEventService:connectToEvent("ResetInventory", function(player, _args)
        self:handleResetInventory(player)
    end)
end

---@param player Player
function InventoryRemoteService:handleGetInventory(player)
    local userId = tostring(player.UserId)

    local inventory = self.inventoryService:getPlayerInventory(userId)

    if inventory then
        local inventoryData = inventory:toDataStructure()
        self.logger:info("InventoryRemoteService", "Sending inventory to player", player.Name, "- equippedItems:", inventoryData.equippedItems)
        self.remoteEventService:fireClient(player, "InventoryUpdated", inventoryData)
    else
        self.logger:error("InventoryRemoteService", "Failed to load inventory for player", player.Name)
        self.remoteEventService:fireClient(player, "Error", {message = "Failed to load inventory"})
    end
end

---@param player Player
---@param args table
function InventoryRemoteService:handleAddItem(player, args)
    local userId = tostring(player.UserId)
    local itemId = args.itemId
    local count = args.count or 1

    if not itemId then
        self.remoteEventService:fireClient(player, "Error", {message = "ItemId is required"})
        return
    end

    local success, errorMessage = self.inventoryService:addItem(userId, itemId, count)
    if success then
        self.remoteEventService:fireClient(player, "ItemAdded", {itemId = itemId, count = count})
        -- Отправить обновленный инвентарь
        self:handleGetInventory(player)
    else
        self.remoteEventService:fireClient(player, "Error", {message = errorMessage or "Failed to add item"})
    end
end

---@param player Player
---@param args table
function InventoryRemoteService:handleRemoveItem(player, args)
    local userId = tostring(player.UserId)
    local itemId = args.itemId
    local count = args.count or 1

    if not itemId then
        self.remoteEventService:fireClient(player, "Error", {message = "ItemId is required"})
        return
    end

    local success, errorMessage = self.inventoryService:removeItem(userId, itemId, count)
    if success then
        self.remoteEventService:fireClient(player, "ItemRemoved", {itemId = itemId, count = count})
        -- Отправить обновленный инвентарь
        self:handleGetInventory(player)
    else
        self.remoteEventService:fireClient(player, "Error", {message = errorMessage or "Failed to remove item"})
    end
end

---@param player Player
---@param args table
function InventoryRemoteService:handleEquipItem(player, args)
    local userId = tostring(player.UserId)
    local slotId = args.slotId
    local slotName = args.slotName

    if not slotId or not slotName then
        self.remoteEventService:fireClient(player, "Error", {message = "SlotId and slotName are required"})
        return
    end

    local success, errorMessage = self.inventoryService:equipItem(userId, slotId, slotName)
    if success then
        self.remoteEventService:fireClient(player, "ItemEquipped", {slotId = slotId, slotName = slotName})
        -- Отправить обновленный инвентарь
        self:handleGetInventory(player)
    else
        self.remoteEventService:fireClient(player, "Error", {message = errorMessage or "Failed to equip item"})
    end
end

---@param player Player
---@param args table
function InventoryRemoteService:handleUnequipItem(player, args)
    local userId = tostring(player.UserId)
    local slotName = args.slotName

    self.logger:info("InventoryRemoteService", "Handling unequip request from player:", player.Name, "slot:", slotName)

    if not slotName then
        self.logger:error("InventoryRemoteService", "SlotName is required for unequip")
        self.remoteEventService:fireClient(player, "Error", {message = "SlotName is required"})
        return
    end

    local success, unequippedItem = self.inventoryService:unequipItem(userId, slotName)
    if success then
        self.logger:info("InventoryRemoteService", "Successfully unequipped item:", unequippedItem)
        self.remoteEventService:fireClient(player, "ItemUnequipped", {slotId = unequippedItem or ""})
        -- Отправить обновленный инвентарь
        self:handleGetInventory(player)
    else
        self.logger:error("InventoryRemoteService", "Failed to unequip item:", unequippedItem)
        self.remoteEventService:fireClient(player, "Error", {message = unequippedItem or "Failed to unequip item"})
    end
end

---@param player Player
function InventoryRemoteService:handleResetInventory(player)
    local userId = tostring(player.UserId)

    self.logger:info("InventoryRemoteService", "Handling reset inventory request from player:", player.Name)

    local success = self.inventoryService:resetPlayerInventory(userId)
    if success then
        self.logger:info("InventoryRemoteService", "Successfully reset inventory for player:", player.Name)
        self.remoteEventService:fireClient(player, "InventoryReset", {})
        -- Отправить обновленный инвентарь
        self:handleGetInventory(player)
    else
        self.logger:error("InventoryRemoteService", "Failed to reset inventory for player:", player.Name)
        self.remoteEventService:fireClient(player, "Error", {message = "Failed to reset inventory"})
    end
end

return InventoryRemoteService
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="30">
                <Properties>
                  <string name="Name">InventoryService</string>
                  <string name="Source"><![CDATA[local MetaService = require(game.ServerScriptService.MetaService)

---@class InventoryService
---@field logger Logger
---@field inventoryRepository InventoryRepository
---@field amuletsList table<string, string>
---@field ringsList table<string, string>
---@field EquipmentSlot EquipmentSlotEntity?
local InventoryService = {}
InventoryService.__index = InventoryService

---@param logger Logger
---@param inventoryRepository InventoryRepository
---@param amuletsList table<string, string>
---@param ringsList table<string, string>
---@param fruitsList table<string, string>
---@param EquipmentSlot EquipmentSlotEntity?
---@return InventoryService
function InventoryService.new(logger, inventoryRepository, amuletsList, ringsList, fruitsList, EquipmentSlot)
	local self = setmetatable({}, InventoryService)
	self.logger = logger
	self.inventoryRepository = inventoryRepository
	self.amuletsList = amuletsList or {}
	self.ringsList = ringsList or {}
	self.fruitsList = fruitsList or {}

	-- Объединяем списки предметов в один словарь для валидации
	self.allItemIcons = {}
	for itemName, iconId in pairs(amuletsList or {}) do
		self.allItemIcons[itemName] = iconId
	end
	for itemName, iconId in pairs(ringsList or {}) do
		self.allItemIcons[itemName] = iconId
	end
	for itemName, iconId in pairs(fruitsList or {}) do
		self.allItemIcons[itemName] = iconId
	end

	self.EquipmentSlot = EquipmentSlot
	return self
end

---@param userId string
---@return InventoryEntity?
function InventoryService:getPlayerInventory(userId)
	local inventory = self.inventoryRepository:getByPlayerId(userId)
	return inventory
end

---@param userId string
---@return boolean
function InventoryService:resetPlayerInventory(userId)
	local metaPlayer = self.inventoryRepository:_getMetaPlayer(userId)
	if not metaPlayer then
		return false
	end

	-- Очистить данные инвентаря
	metaPlayer.Data.Inventory.Accessories = {}

	-- Создать новый пустой инвентарь
	local emptyInventory = self.inventoryRepository.InventoryEntity.new()
	self.inventoryRepository:save(userId, emptyInventory)

	return true
end

---@param userId string
---@param itemId string
---@param count number
---@return boolean, string?
function InventoryService:addItem(userId, itemId, count)
	if count <= 0 then
		return false, "Invalid item count"
	end

	-- Валидация предмета - проверить что он существует в списке предметов
	if not self.allItemIcons[itemId] then
		return false, "Unknown item"
	end

	local inventory = self.inventoryRepository:getByPlayerId(userId)
	if not inventory then
		return false, "Player inventory not found"
	end

	-- Проверить лимит инвентаря
	if inventory:isFull() then
		return false, "Inventory is full"
	end

	local success = self.inventoryRepository:addItemToPlayer(userId, itemId, count)
	if not success then
		return false, "Failed to add item to inventory"
	end

	return true, nil
end

---@param userId string
---@param itemId string
---@param count number
---@return boolean, string?
function InventoryService:removeItem(userId, itemId, count)
	if count <= 0 then
		return false, "Invalid item count"
	end

	local inventory = self.inventoryRepository:getByPlayerId(userId)
	if not inventory then
		return false, "Player inventory not found"
	end

	if inventory:getItemCount(itemId) < count then
		return false, "Insufficient item count"
	end

	-- Проверить, что ни один экземпляр этого предмета не экипирован
	for _, equippedSlotId in pairs(inventory.equippedItems) do
		local equippedItemName = string.match(equippedSlotId, "^(.+)_%d+$")
		if equippedItemName == itemId then
			return false, "Cannot remove equipped item"
		end
	end

	local success = self.inventoryRepository:removeItemFromPlayer(userId, itemId, count)
	if not success then
		return false, "Failed to remove item from inventory"
	end

	return true, nil
end

---@param userId string
---@param slotId string
---@param slotName string
---@return boolean, string?
function InventoryService:equipItem(userId, slotId, slotName)
	local inventory = self.inventoryRepository:getByPlayerId(userId)
	if not inventory then
		return false, "Player inventory not found"
	end

	-- Извлечь itemName из slotId
	local itemName = string.match(slotId, "^(.+)_%d+$")
	if not itemName then
		return false, "Invalid slotId format"
	end


	-- Проверить, есть ли предмет в инвентаре
	if not inventory:hasItem(itemName) then
		return false, "Item not found in inventory"
	end

	-- Проверить, что slotId существует в inventorySlots
	local slotExists = false
	if inventory.inventorySlots[itemName] then
		for _, slotData in ipairs(inventory.inventorySlots[itemName]) do
			if slotData.slotId == slotId then
				slotExists = true
				break
			end
		end
	end
	if not slotExists then
		return false, "Slot not found in inventory"
	end

	local slot = self.EquipmentSlot:getByName(slotName)
	if not slot then
		return false, "Invalid equipment slot"
	end

	-- Проверить, что слот свободен
	local equippedItem = inventory:getEquippedItem(slot)
	if equippedItem then
		self.logger:warn("InventoryService", "Cannot equip item - slot", slotName, "is already occupied by:", equippedItem)
		return false, "Equipment slot is already occupied"
	end

	-- Валидация предмета - проверить что он существует и может быть экипирован
	if not self.allItemIcons[itemName] then
		return false, "Unknown item"
	end

	-- Проверить, что предмет не является фруктом
	if self.fruitsList[itemName] then
		local metaPlayer = MetaService.Class.Player:Get(game.Players:GetPlayerByUserId(tonumber(userId)))
		metaPlayer:Notification("Fruits cannot be equipped", 3, Color3.new(1, 0.239215, 0.239215))
		return false, "Fruits cannot be equipped"
	end

	-- Проверить совместимость слота с типом предмета
	local itemType = self:getItemType(itemName)
	if not slot:canEquipItemType(itemType) then
		return false, "Item cannot be equipped in this slot"
	end

	local success = self.inventoryRepository:equipItem(userId, slotId, slot)
	if not success then
		self.logger:error("InventoryService", "Failed to equip item in repository")
		return false, "Failed to equip item"
	end

	self.logger:info("InventoryService", "Successfully equipped item:", slotId, "in slot:", slotName)
	return true, nil
end

---@param userId string
---@param slotName string
---@return boolean, string?
function InventoryService:unequipItem(userId, slotName)
	self.logger:info("InventoryService", "Unequipping item for user", userId, "from slot:", slotName)

	local inventory = self.inventoryRepository:getByPlayerId(userId)
	if not inventory then
		self.logger:error("InventoryService", "Player inventory not found for user:", userId)
		return false, "Player inventory not found"
	end

	-- Получить слот экипировки
	local slot = self.EquipmentSlot:getByName(slotName)
	if not slot then
		self.logger:error("InventoryService", "Invalid equipment slot:", slotName)
		return false, "Invalid equipment slot"
	end

	-- Проверить, есть ли что-то в слоте
	local equippedItem = inventory:getEquippedItem(slot)
	if not equippedItem then
		self.logger:warn("InventoryService", "No item equipped in slot:", slotName)
		return false, "No item equipped in this slot"
	end

	self.logger:info("InventoryService", "Unequipping item:", equippedItem, "from slot:", slotName)

	local success, unequippedItem = self.inventoryRepository:unequipItem(userId, slot)
	if not success then
		self.logger:error("InventoryService", "Failed to unequip item from repository")
		return false, "Failed to unequip item"
	end

	self.logger:info("InventoryService", "Successfully unequipped item:", unequippedItem)
	return true, unequippedItem
end

---@param itemId string
---@return string
function InventoryService:getItemType(itemId)
	if self.amuletsList[itemId] then
		return "amulet"
	elseif self.ringsList[itemId] then
		return "ring"
	elseif self.fruitsList[itemId] then
		return "weapon" -- фрукты считаем оружием
	end

	return "weapon" -- по умолчанию
end

---@param userId string
---@param itemId string
---@return boolean
function InventoryService:hasItem(userId, itemId)
	local inventory = self.inventoryRepository:getByPlayerId(userId)
	return inventory and inventory:hasItem(itemId) or false
end

---@param userId string
---@param itemId string
---@return number
function InventoryService:getItemCount(userId, itemId)
	local inventory = self.inventoryRepository:getByPlayerId(userId)
	return inventory and inventory:getItemCount(itemId) or 0
end

return InventoryService
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="StringValue" referent="31">
            <Properties>
              <string name="Name">_version</string>
              <string name="Value">v0.0.12</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="32">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="33">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="ModuleScript" referent="34">
        <Properties>
          <string name="Name">MetaService</string>
        </Properties>
        <Item class="Folder" referent="35">
          <Properties>
            <string name="Name">Client</string>
          </Properties>
          <Item class="ModuleScript" referent="36">
            <Properties>
              <string name="Name">Inventory</string>
            </Properties>
            <Item class="ModuleScript" referent="37">
              <Properties>
                <string name="Name">InventorySystemClient</string>
                <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Shared = require(ReplicatedStorage.Shared.InventorySystemShared)

local InventoryUI = require(script.UI.InventoryUI)
local InventoryService = require(script.Services.InventoryService)

local MetaService = require(game.StarterPlayer.StarterPlayerScripts.MetaService)


---@class InventorySystemClient
---@field shared InventorySystemShared
---@field diContainer DIContainer
local Client = {}
Client.__index = Client

function Client.new()
	local self = setmetatable({}, Client)
	self.shared = Shared.new()
	self.diContainer = self.shared.infrastructure.diContainer
	self.MetaService = MetaService
	self:_registerServices()
	return self
end

function Client:_registerServices()
	-- Регистрация InventoryClientService
	self.diContainer:singleton("InventoryClientService", function(container)
		local remoteEventService = container:resolve("RemoteEventService")
		---@type InventorySystemData
		local data = container:resolve("Shared.Data")
		local logger = container:resolve("Logger")
		local amuletsList = data.AmuletsList
		local ringsList = data.RingsList
		local fruitsList = data.FruitsList
		return InventoryService.new(remoteEventService, amuletsList, ringsList, fruitsList, logger)
	end)

	-- Регистрация InventoryUI
	self.diContainer:singleton("InventoryUI", function(container)
		local inventoryClientService = container:resolve("InventoryClientService")
		---@type InventorySystemData
		local data = container:resolve("Shared.Data")
		---@type InventorySystemDomain
		local domain = container:resolve("Shared.Domain")
		local logger = container:resolve("Logger")

		local EquipmentSlotEntity = domain.entities.EquipmentSlot
		local ItemEntity = domain.entities.Item
		local amuletsList = data.AmuletsList
		local fruitsList = data.FruitsList
		local ringsList = data.RingsList
		local bonusIcons = data.BonusIcons

		return InventoryUI.new(inventoryClientService, amuletsList, fruitsList, ringsList, bonusIcons, EquipmentSlotEntity, ItemEntity, logger)
	end)
end

function Client:init()
	self.shared:init()
	self.diContainer:resolve("InventoryClientService")
	self.diContainer:resolve("InventoryUI")
end

---@return InventoryClientService
function Client:getInventoryClientService()
	return self.diContainer:resolve("InventoryClientService")
end

---@return InventoryUI
function Client:getInventoryUI()
	return self.diContainer:resolve("InventoryUI")
end

local client = Client.new()
client:init()

return Client
]]></string>
              </Properties>
              <Item class="Folder" referent="38">
                <Properties>
                  <string name="Name">Services</string>
                </Properties>
                <Item class="ModuleScript" referent="39">
                  <Properties>
                    <string name="Name">InventoryService</string>
                    <string name="Source"><![CDATA[---@class InventoryClientService
---@field remoteEventService RemoteEventService
---@field _inventoryData table?
---@field _onInventoryUpdated function?
---@field _onItemEquipped function?
local InventoryClientService = {}
InventoryClientService.__index = InventoryClientService

---@param remoteEventService RemoteEventService
---@param logger LoggerService
---@return InventoryClientService
function InventoryClientService.new(remoteEventService, amuletsList, ringsList, fruitsList, logger)
	local self = setmetatable({}, InventoryClientService)
	self.remoteEventService = remoteEventService
	self._inventoryData = nil
	self._onInventoryUpdated = nil
	self._onItemEquipped = nil
	self._amuletsList = amuletsList
	self._ringsList = ringsList
	self._fruitsList = fruitsList
	self.logger = logger
	self:setupEventHandlers()
	return self
end

function InventoryClientService:setupEventHandlers()
	self.logger:info("InventoryClientService", "Setting up event handlers")

	-- Обработчик обновления инвентаря
	self.remoteEventService:connectToEvent("InventoryUpdated", function(args)
		self.logger:info("InventoryClientService", "Received InventoryUpdated event - equippedItems:", args.equippedItems or "none")
		self._inventoryData = args
		if self._onInventoryUpdated then
			self._onInventoryUpdated(self._inventoryData)
		else
			self.logger:warn("InventoryClientService", "No _onInventoryUpdated callback set")
		end
	end)

	-- Обработчик ошибок
	self.remoteEventService:connectToEvent("Error", function(args)
		self.logger:error("InventoryClientService", "Received Error event:", args)
	end)

	-- Обработчик успешного добавления предмета
	self.remoteEventService:connectToEvent("ItemAdded", function(args)
		self.logger:info("InventoryClientService", "Received ItemAdded event:", args)
	end)

	-- Обработчик успешного удаления предмета
	self.remoteEventService:connectToEvent("ItemRemoved", function(args)
		self.logger:info("InventoryClientService", "Received ItemRemoved event:", args)
	end)

	-- Обработчик сброса инвентаря
	self.remoteEventService:connectToEvent("InventoryReset", function(args)
		self.logger:info("InventoryClientService", "Received InventoryReset event:", args)
		-- Очистить локальные данные
		self._inventoryData = nil
	end)

	-- Обработчик успешной экипировки
	self.remoteEventService:connectToEvent("ItemEquipped", function(args)
		self.logger:info("InventoryClientService", "Received ItemEquipped event - slotId:", args.slotId, "slotName:", args.slotName)

		-- Обновляем локальные данные equippedItems
		if self._inventoryData and self._inventoryData.equippedItems then
			self._inventoryData.equippedItems[args.slotName] = args.slotId
			self.logger:debug("InventoryClientService", "Updated local equippedItems:", self._inventoryData.equippedItems)
		end

		if self._onItemEquipped then
			self._onItemEquipped(args.slotId, args.slotName)
		else
			self.logger:warn("InventoryClientService", "No _onItemEquipped callback set")
		end
	end)

	-- Обработчик успешного снятия экипировки
	self.remoteEventService:connectToEvent("ItemUnequipped", function(args)
		self.logger:info("InventoryClientService", "Received ItemUnequipped event - slotId:", args.slotId)

		-- Обновляем локальные данные equippedItems
		if self._inventoryData and self._inventoryData.equippedItems then
			-- Находим и удаляем slotId из equippedItems
			for slotName, equippedSlotId in pairs(self._inventoryData.equippedItems) do
				if equippedSlotId == args.slotId then
					self._inventoryData.equippedItems[slotName] = nil
					self.logger:debug("InventoryClientService", "Removed from local equippedItems:", slotName)
					break
				end
			end
		end

		if self._onItemUnequipped then
			self._onItemUnequipped(args.slotId)
		end
	end)
end

---@return table?
function InventoryClientService:getInventoryData()
	return self._inventoryData
end

--- Запросить инвентарь с сервера
function InventoryClientService:requestInventory()
	self.logger:info("InventoryClientService", "Requesting inventory from server")
	self.remoteEventService:fireServer("GetInventory", {})
end

---@param itemId string
---@param count number?
function InventoryClientService:requestAddItem(itemId, count)
	self.remoteEventService:fireServer("AddItem", {
		itemId = itemId,
		count = count or 1,
	})
end

---@param itemId string
---@param count number?
function InventoryClientService:requestRemoveItem(itemId, count)
	self.logger:info("InventoryClientService", "Requesting to remove item:", itemId, "count:", count or 1)
	self.remoteEventService:fireServer("RemoveItem", {
		itemId = itemId,
		count = count or 1,
	})
end

---@param slotId string
---@param slotName string
function InventoryClientService:requestEquipItem(slotId, slotName)
	self.logger:info("InventoryClientService", "Requesting to equip item. SlotId:", slotId, "SlotName:", slotName)
	self.remoteEventService:fireServer("EquipItem", {
		slotId = slotId,
		slotName = slotName,
	})
end

---@param slotName string
function InventoryClientService:requestUnequipItem(slotName)
	self.logger:info("InventoryClientService", "Requesting to unequip item from slot:", slotName)
	self.remoteEventService:fireServer("UnequipItem", {
		slotName = slotName,
	})
end

--- Запросить сброс инвентаря
function InventoryClientService:requestResetInventory()
	self.logger:info("InventoryClientService", "Requesting to reset inventory")
	self.remoteEventService:fireServer("ResetInventory", {})
end

---@param itemId string
---@return number
function InventoryClientService:getItemCount(itemId)
	if not self._inventoryData or not self._inventoryData.inventorySlots then
		return 0
	end

	for _, slot in ipairs(self._inventoryData.inventorySlots) do
		if slot.id == itemId then
			return slot.count
		end
	end
	return 0
end

---@param itemId string
---@return boolean
function InventoryClientService:hasItem(itemId)
	return self:getItemCount(itemId) > 0
end

---@param slotName string
---@return string?
function InventoryClientService:getEquippedItem(slotName)
	if not self._inventoryData or not self._inventoryData.equippedItems then
		return nil
	end

	return self._inventoryData.equippedItems[slotName]
end

---@return table
function InventoryClientService:getInventorySlots()
	if not self._inventoryData or not self._inventoryData.inventorySlots then
		return {}
	end

	return self._inventoryData.inventorySlots
end

---@return table
function InventoryClientService:getEquippedItems()
	if not self._inventoryData or not self._inventoryData.equippedItems then
		return {}
	end

	return self._inventoryData.equippedItems
end

function InventoryClientService:setOnInventoryUpdated(callback)
	self._onInventoryUpdated = callback
end

---@param callback function(itemId: string, slotName: string)
function InventoryClientService:setOnItemEquipped(callback)
	self._onItemEquipped = callback
end

---@param callback function(slotId: string)
function InventoryClientService:setOnItemUnequipped(callback)
	self._onItemUnequipped = callback
end

---@param itemId string
---@return string
function InventoryClientService:getItemType(itemId)
	if self._amuletsList[itemId] then
		return "amulet"
	elseif self._ringsList[itemId] then
		return "ring"
	elseif self._fruitsList[itemId] then
		return "weapon" -- фрукты считаем оружием
	end

	return "weapon" -- по умолчанию
end

return InventoryClientService
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="40">
                <Properties>
                  <string name="Name">UI</string>
                </Properties>
                <Item class="ModuleScript" referent="41">
                  <Properties>
                    <string name="Name">InventoryUI</string>
                    <string name="Source"><![CDATA[local Players = game:GetService("Players")
local MetaService = require(game.StarterPlayer.StarterPlayerScripts.MetaService)
---@class InventoryUI
---@field screenGui ScreenGui
---@field mainFrame Frame
---@field inventoryFrame Frame
---@field equipmentFrame Frame
---@field selectedItem table?
---@field isEquipmentWindowOpen boolean
---@field inventoryClientService InventoryClientService
---@field inventorySlots table
---@field equipmentSlots table
---@field equipButton TextButton?
---@field EquipmentSlotEntity EquipmentSlotEntity
---@field ItemEntity ItemEntity
---@field draggedItem table?
---@field dragIcon ImageLabel?
---@field isDeleteMode boolean
---@field deleteModeButton TextButton?
---@field slotsInfoLabel TextLabel?
local InventoryUI = {}
InventoryUI.__index = InventoryUI

---@param inventoryClientService InventoryClientService
---@param amuletsList AmuletsList
---@param fruitsList FruitsList
---@param ringsList RingsList
---@param bonusIcons table
---@param EquipmentSlotEntity EquipmentSlotEntity
---@param ItemEntity ItemEntity
---@param logger LoggerService
---@return InventoryUI
function InventoryUI.new(inventoryClientService, amuletsList, fruitsList, ringsList, bonusIcons, EquipmentSlotEntity, ItemEntity, logger)
	local self = setmetatable({}, InventoryUI)
	self.inventoryClientService = inventoryClientService
	self.amuletsList = amuletsList
	self.fruitsList = fruitsList
	self.ringsList = ringsList
	self.bonusIcons = bonusIcons
	self.logger = logger
	-- Объединяем списки предметов в один словарь
	self.allItemIcons = {}
	self.allItemBonuses = {}
	for itemName, itemData in pairs(amuletsList) do
		self.allItemIcons[itemName] = itemData.icon
		self.allItemBonuses[itemName] = {
			bonusType = itemData.bonusType,
			bonusValue = itemData.bonusValue
		}
	end
	for itemName, itemData in pairs(fruitsList) do
		self.allItemIcons[itemName] = itemData.icon
		self.allItemBonuses[itemName] = {
			bonusType = itemData.bonusType,
			bonusValue = itemData.bonusValue
		}
	end
	for itemName, itemData in pairs(ringsList) do
		self.allItemIcons[itemName] = itemData.icon
		self.allItemBonuses[itemName] = {
			bonusType = itemData.bonusType,
			bonusValue = itemData.bonusValue
		}
	end

	self.selectedItem = nil
	self.isEquipmentWindowOpen = false
	self.EquipmentSlotEntity = EquipmentSlotEntity
	self.ItemEntity = ItemEntity
	self.inventorySlots = {}
	self.itemSlots = {}
	self.equipmentSlots = {}
	self.draggedItem = nil
	self.isDeleteMode = false

	self:createUI()
	self:setupEventHandlers()
	self:setupEquipmentSlots()
	return self
end

function InventoryUI:createUI()
	self.logger:info("InventoryUI", "Creating UI elements")
	local player = Players.LocalPlayer
	local UI = player.PlayerGui:WaitForChild("UI")
	local frames = UI.Frames
	self.mainFrame = frames.Inventory.NewMain.body.lists.Accessories
	self.inventoryFrame = self.mainFrame.ScrollingFrame
	self.equipmentFrame = self.mainFrame.EquipmentFrame
	self.slotTemplate = self.mainFrame.ScrollingFrame.Template

	self.logger:debug("InventoryUI", "UI elements created - mainFrame:", self.mainFrame and "found" or "not found")

	-- Найти кнопку режима удаления
	self.deleteModeButton = self.equipmentFrame:FindFirstChild("DeleteModeButton")
	if self.deleteModeButton then
		self.logger:debug("InventoryUI", "DeleteModeButton found, connecting click handler")
		self.deleteModeButton.MouseButton1Click:Connect(function()
			self:toggleDeleteMode()
		end)
		self:updateDeleteModeButton()
	else
		self.logger:warn("InventoryUI", "DeleteModeButton not found")
	end

	-- Найти кнопку сброса инвентаря
	self.resetButton = self.equipmentFrame:FindFirstChild("ResetButton")
	if self.resetButton then
		self.logger:debug("InventoryUI", "ResetButton found, connecting click handler")
		self.resetButton.MouseButton1Click:Connect(function()
			self:resetInventory()
		end)
	else
		self.logger:warn("InventoryUI", "ResetButton not found")
	end

	-- Найти TextLabel для информации о слотах
	self.slotsInfoLabel = self.mainFrame:FindFirstChild("SlotsInfoLabel")
	if self.slotsInfoLabel then
		self.logger:debug("InventoryUI", "SlotsInfoLabel found")
	else
		self.logger:warn("InventoryUI", "SlotsInfoLabel not found")
	end

	self.mainFrame:GetPropertyChangedSignal("Visible"):Connect(function()
		local visible = self.mainFrame.Visible
		self.logger:info("InventoryUI", "Inventory visibility changed to:", visible)
		self.isDeleteMode = false
		self:updateDeleteModeButton()
		if visible then
			self.logger:info("InventoryUI", "Inventory opened, requesting inventory data")
			self.inventoryClientService:requestInventory()
		else
			self.logger:info("InventoryUI", "Inventory closed, clearing slots")
			self.selectedItem = nil
			self:clearSlots()
			-- Сбросить режим удаления при закрытии инвентаря
			if self.isDeleteMode then
				self:toggleDeleteMode()
			end
		end
	end)
end

function InventoryUI:toggleDeleteMode()
	self.isDeleteMode = not self.isDeleteMode
	self:updateDeleteModeButton()

	if self.isDeleteMode then
		MetaService.Self:Fire(
			"Notification",
			"Create",
			"Delete mode enabled - click items to remove them",
			3,
			Color3.new(1, 0.5, 0)
		)
	else
		MetaService.Self:Fire("Notification", "Create", "Delete mode disabled", 3, Color3.new(0, 1, 0))
	end
end

function InventoryUI:resetInventory()
	MetaService.Self:Fire(
		"Notification",
		"Create",
		"Resetting inventory...",
		3,
		Color3.new(1, 0.5, 0)
	)
	self.inventoryClientService:requestResetInventory()
end

function InventoryUI:updateDeleteModeButton()
	if self.isDeleteMode then
		self.deleteModeButton.ImageLabel.ImageTransparency = 0
		self.deleteModeButton.TextLabel.Visible = true
	else
		self.deleteModeButton.ImageLabel.ImageTransparency = 0.5
		self.deleteModeButton.TextLabel.Visible = false
	end
end

function InventoryUI:setupEquipmentSlots()
	self.logger:info("InventoryUI", "Setting up equipment slots")
	for _, slotData in ipairs(self.EquipmentSlotEntity.getAllSlots()) do
		local buttonName = "EquipSlot_" .. slotData.name
		local slotButton = self.equipmentFrame:FindFirstChild(buttonName)
		self.logger:info("InventoryUI", "Looking for slot button:", buttonName, "found:", slotButton ~= nil)

		local slot =
			self.EquipmentSlotEntity.new(slotData.name, slotData.displayName, slotData.allowedItemTypes, slotButton)

		-- Подключаем обработчик клика для снятия экипировки
		if slotButton then
			slotButton.MouseButton1Click:Connect(function()
				self:onEquipmentSlotClicked(slotData.name)
			end)
			self.logger:info("InventoryUI", "Connected click handler for slot:", slotData.name)
		else
			self.logger:warn("InventoryUI", "Slot button not found for:", slotData.name)
		end

		table.insert(self.equipmentSlots, slot)
	end
	self.logger:info("InventoryUI", "Equipment slots setup complete, total slots:", #self.equipmentSlots)
end

function InventoryUI:createSlots(inventoryData)
	-- Очищаем существующие слоты перед созданием новых
	self:clearSlots()

	local slotIndex = 0
	for itemName, itemSlots in pairs(inventoryData.inventorySlots) do
		-- Для каждого экземпляра предмета создаем отдельный слот
		for i, _ in ipairs(itemSlots) do
			slotIndex = slotIndex + 1
			local slot = self.slotTemplate:Clone()
			local slotId = itemName .. "_" .. i -- Уникальный ID для каждого слота
			slot.Name = slotId
			slot.CountLabel.Text = "1" -- Каждый слот содержит 1 экземпляр
			slot.Parent = self.inventoryFrame
			slot.ItemNameLabel.Text = itemName
			slot.ItemIcon.Image = self.allItemIcons[itemName] or ""
			slot.Visible = true

			-- Проверяем, экипирован ли этот конкретный слот, и показываем Checkmark
			local currentInventoryData = self.inventoryClientService:getInventoryData()
			local checkmark = slot:FindFirstChild("Checkmark")
			if checkmark then
				local isEquipped = false
				if currentInventoryData and currentInventoryData.equippedItems then
					for _, equippedSlotId in pairs(currentInventoryData.equippedItems) do
						if equippedSlotId == slotId then
							isEquipped = true
							break
						end
					end
				end
				checkmark.Visible = isEquipped
			end

			-- Устанавливаем иконку и значение бонуса
			local bonusData = self.allItemBonuses[itemName]
			if bonusData then
				local bonusIconLabel = slot:FindFirstChild("BonusIconLabel")
				if bonusIconLabel then
					-- Скрываем bonusIconLabel для фруктов
					if self.fruitsList[itemName] then
						bonusIconLabel.Visible = false
					else
						local bonusIcon = self.bonusIcons[bonusData.bonusType]
						if bonusIcon then
							bonusIconLabel.Image = bonusIcon
							local bonusValueLabel = bonusIconLabel:FindFirstChild("BonusValueLabel")
							if bonusValueLabel then
								bonusValueLabel.Text = "+" .. tostring(bonusData.bonusValue * 100) .. "%"
							end
						end
					end
				end
			end

			slot.MouseButton1Click:Connect(function()
				self:onSlotClicked(slotId) -- Передаем уникальный ID слота
			end)

			local item = self.ItemEntity.new(slotId, itemName, "weapon", slot)
			table.insert(self.inventorySlots, item)
			self.itemSlots[slotId] = slot -- Сохраняем UI слот по уникальному ID
		end
	end
end

function InventoryUI:clearSlots()
	for _, slot in pairs(self.inventorySlots) do
		slot:destroy()
	end
	self.inventorySlots = {}
	self.itemSlots = {}
end

function InventoryUI:setupEventHandlers()
	self.logger:info("InventoryUI", "Setting up event handlers")

	-- Обработчик обновления инвентаря
	self.inventoryClientService:setOnInventoryUpdated(function(inventoryData)
		self.logger:info("InventoryUI", "Inventory updated event received")
		self:createSlots(inventoryData)
		self:updateEquipmentSlots()
		self:updateSlotsInfoLabel()
	end)

	-- Обработчик успешной экипировки
	self.inventoryClientService:setOnItemEquipped(function(itemId, slotName)
		self.logger:info("InventoryUI", "Item equipped event received - itemId:", itemId, "slotName:", slotName)
		self:onItemEquipped(itemId)
	end)

	-- Обработчик снятия экипировки
	local remoteEventService = self.inventoryClientService.remoteEventService
	remoteEventService:connectToEvent("ItemUnequipped", function(args)
		self.logger:info("InventoryUI", "Item unequipped event received - slotId:", args.slotId)
		self:onItemUnequipped(args.slotId)
	end)
end

function InventoryUI:onSlotClicked(slotId)
	self.logger:info("InventoryUI", "onSlotClicked called with slotId:", slotId)

	if self.isEquipmentWindowOpen then
		self.logger:info("InventoryUI", "Equipment window is open, ignoring slot click")
		return
	end

	local inventoryData = self.inventoryClientService:getInventoryData()
	if not inventoryData then
		self.logger:warn("InventoryUI", "No inventory data available")
		return
	end

	-- Извлекаем имя предмета из slotId (убираем "_номер")
	local itemName = string.match(slotId, "^(.+)_%d+$")
	if not itemName then
		self.logger:error("InventoryUI", "Failed to extract itemName from slotId:", slotId)
		return
	end

	self.logger:info("InventoryUI", "Processing click for item:", itemName, "from slot:", slotId)

	if self.isDeleteMode then
		self.logger:info("InventoryUI", "Delete mode active, deleting item:", itemName)
		-- Режим удаления - удаляем один экземпляр предмета
		self:deleteItem(itemName, 1)
	else
		self.logger:info("InventoryUI", "Normal mode - checking equipment status for slot:", slotId)
		-- Обычный режим - экипировка/снятие
		-- Сбрасываем выделение всех UI слотов
		for _, slotButton in pairs(self.itemSlots) do
			slotButton.BorderColor3 = Color3.fromRGB(100, 100, 100)
		end

		-- Выделяем текущий слот
		if self.itemSlots[slotId] then
			self.itemSlots[slotId].BorderColor3 = Color3.fromRGB(255, 255, 0) -- Желтая рамка для выделения
			self.logger:debug("InventoryUI", "Highlighted slot:", slotId)
		else
			self.logger:warn("InventoryUI", "Slot button not found for slotId:", slotId)
		end

		-- Проверяем, экипирован ли уже этот конкретный слот
		local isEquipped = false
		local equippedSlotName = nil
		if inventoryData.equippedItems then
			self.logger:debug("InventoryUI", "Checking equipped items:", inventoryData.equippedItems)
			for slotName, equippedSlotId in pairs(inventoryData.equippedItems) do
				if equippedSlotId == slotId then
					isEquipped = true
					equippedSlotName = slotName
					break
				end
			end
		else
			self.logger:warn("InventoryUI", "No equippedItems in inventory data")
		end

		if isEquipped then
			self.logger:info("InventoryUI", "Item is equipped in slot:", equippedSlotName, "- requesting unequip")
			-- Этот слот экипирован, снимаем его
			self.inventoryClientService:requestUnequipItem(equippedSlotName)
		else
			self.logger:info("InventoryUI", "Item is not equipped, looking for free slot")
			-- Этот слот не экипирован, ищем свободный слот экипировки
			local itemType = self.inventoryClientService:getItemType(itemName)
			self.logger:debug("InventoryUI", "Item type:", itemType)
			local freeSlot = self:findFreeEquipmentSlot(itemType)
			if freeSlot then
				self.logger:info("InventoryUI", "Found free slot:", freeSlot:getName(), "- requesting equip")
				-- Отправляем запрос на экипировку этого конкретного слота
				self.inventoryClientService:requestEquipItem(slotId, freeSlot:getName())
			else
				self.logger:warn("InventoryUI", "No free equipment slot found for item type:", itemType)
				MetaService.Self:Fire(
					"Notification",
					"Create",
					"No free equipment slot available for item",
					5,
					Color3.new(0.8, 0, 1)
				)
			end
		end
	end
end

function InventoryUI:deleteItem(itemId, count)
	if count <= 0 then
		return
	end

	-- Проверяем, экипирован ли хотя бы один экземпляр этого предмета
	local inventoryData = self.inventoryClientService:getInventoryData()
	if inventoryData and inventoryData.equippedItems then
		for _, equippedSlotId in pairs(inventoryData.equippedItems) do
			-- Извлекаем itemName из equippedSlotId
			local equippedItemName = string.match(equippedSlotId, "^(.+)_%d+$")
			if equippedItemName == itemId then
				-- Предмет экипирован, нельзя удалить
				MetaService.Self:Fire("Notification", "Create", "Cannot delete equipped item", 3, Color3.new(1, 0, 0))
				return
			end
		end
	end

	-- Отправляем запрос на удаление предмета
	self.inventoryClientService:requestRemoveItem(itemId, count)

	MetaService.Self:Fire("Notification", "Create", `Removed {count}x {itemId}`, 3, Color3.new(1, 0.5, 0))
end

function InventoryUI:findFreeEquipmentSlot(itemType)
	local inventoryData = self.inventoryClientService:getInventoryData()
	if not inventoryData or not inventoryData.equippedItems then
		self.logger:warn("InventoryUI", "No inventory data or equippedItems available")
		return nil
	end

	self.logger:info("InventoryUI", "Finding free slot for item type:", itemType)

	self.logger:info("InventoryUI", "Current equipped items:", inventoryData.equippedItems)

	-- Специальная логика выбора слота в зависимости от типа предмета
	if itemType == "ring" then
		self.logger:info("InventoryUI", "Looking for slot for ring item")
		-- Кольца экипируются в левую руку в первую очередь (как на сервере)
		local leftHandSlot = self.EquipmentSlotEntity.LEFT_HAND
		local leftHandName = leftHandSlot:getName()
		local isLeftHandFree = not inventoryData.equippedItems[leftHandName]
		self.logger:info("InventoryUI", "Left hand slot:", leftHandName, "is free:", isLeftHandFree)
		if isLeftHandFree and leftHandSlot:canEquipItemType(itemType) then
			self.logger:info("InventoryUI", "Selected left hand slot for ring")
			return leftHandSlot
		end
		-- Если левая рука занята, пробуем правую
		local rightHandSlot = self.EquipmentSlotEntity.RIGHT_HAND
		local rightHandName = rightHandSlot:getName()
		local isRightHandFree = not inventoryData.equippedItems[rightHandName]
		self.logger:info("InventoryUI", "Right hand slot:", rightHandName, "is free:", isRightHandFree)
		if isRightHandFree and rightHandSlot:canEquipItemType(itemType) then
			self.logger:info("InventoryUI", "Selected right hand slot for ring")
			return rightHandSlot
		end
	elseif itemType == "weapon" then
		-- Оружие экипируется в левую руку в первую очередь
		local leftHandSlot = self.EquipmentSlotEntity.LEFT_HAND
		if not inventoryData.equippedItems[leftHandSlot:getName()] and leftHandSlot:canEquipItemType(itemType) then
			return leftHandSlot
		end
		-- Если левая рука занята, пробуем правую
		local rightHandSlot = self.EquipmentSlotEntity.RIGHT_HAND
		if not inventoryData.equippedItems[rightHandSlot:getName()] and rightHandSlot:canEquipItemType(itemType) then
			return rightHandSlot
		end
	else
		self.logger:info("InventoryUI", "Using standard slot selection for item type:", itemType)
		-- Для других типов предметов (amulet) используем стандартную логику
		local allSlots = self.EquipmentSlotEntity.getAllSlots()

		-- Ищем первый свободный слот, совместимый с типом предмета
		for _, slot in ipairs(allSlots) do
			local slotName = slot:getName()
			local isSlotFree = not inventoryData.equippedItems[slotName]
			local canEquip = slot:canEquipItemType(itemType)
			self.logger:info("InventoryUI", "Checking slot:", slotName, "is free:", isSlotFree, "can equip:", canEquip)
			if isSlotFree and canEquip then
				self.logger:info("InventoryUI", "Selected slot:", slotName, "for item type:", itemType)
				return slot
			end
		end
	end

	self.logger:info("InventoryUI", "No free slot found for item type:", itemType)
	return nil
end

function InventoryUI:onEquipmentSlotClicked(slotName)
	if self.draggedItem then
		-- Перетаскивание предмета - экипировать в этот слот
		self.inventoryClientService:requestEquipItem(self.draggedItem.id, slotName)
		MetaService.Self:Fire("Notification", "Create", "Equip" .. self.draggedItem.id, 5, Color3.new(0.8, 0, 1))
		return
	end

	-- Обычный клик - проверить, есть ли предмет в слоте
	local inventoryData = self.inventoryClientService:getInventoryData()
	if inventoryData and inventoryData.equippedItems then
		local equippedItemId = inventoryData.equippedItems[slotName]
		if equippedItemId then
			-- Есть предмет в слоте - снимаем его
			self.inventoryClientService:requestUnequipItem(slotName)
			MetaService.Self:Fire("Notification", "Create", "Unequip" .. equippedItemId, 5, Color3.new(0.8, 0, 1))
		end
	end
end

function InventoryUI:onItemEquipped(slotId)
	self.logger:info("InventoryUI", "Item equipped event for slotId:", slotId)

	-- Находим конкретный UI слот и показываем Checkmark
	local slotButton = self.itemSlots[slotId]
	if slotButton then
		local checkmark = slotButton:FindFirstChild("Checkmark")
		if checkmark then
			self.logger:debug("InventoryUI", "Showing checkmark for slotId:", slotId)
			checkmark.Visible = true
		else
			self.logger:warn("InventoryUI", "Checkmark not found for slotId:", slotId)
		end
	else
		self.logger:warn("InventoryUI", "Slot button not found for slotId:", slotId)
	end

	-- Обновление слотов экипировки происходит в обработчике InventoryUpdated,
	-- чтобы избежать дублирования обновлений и потенциальных несоответствий данных
end

function InventoryUI:onItemUnequipped(slotId)
	-- Находим конкретный UI слот и скрываем Checkmark
	local slotButton = self.itemSlots[slotId]
	if slotButton then
		local checkmark = slotButton:FindFirstChild("Checkmark")
		if checkmark then
			checkmark.Visible = false
		end
	end

	-- Обновление слотов экипировки происходит в обработчике InventoryUpdated,
	-- чтобы избежать дублирования обновлений и потенциальных несоответствий данных
end

function InventoryUI:updateEquipmentSlots()
	local inventoryData = self.inventoryClientService:getInventoryData()
	if not inventoryData or not inventoryData.equippedItems then
		self.logger:warn("InventoryUI", "No inventory data for equipment slots update")
		return
	end

	self.logger:info("InventoryUI", "Updating equipment slots with data:", inventoryData.equippedItems)

	-- Получаем все доступные иконки предметов
	local allItemIcons = self.allItemIcons

	for _, slotEntity in ipairs(self.equipmentSlots) do
		local slotName = slotEntity:getName()
		local slotButton = slotEntity.slotButton
		local equippedIcon = slotButton and slotButton:FindFirstChild("EquippedIcon")
		local equippedItemId = inventoryData.equippedItems[slotName]

		self.logger:info("InventoryUI", "Processing slot:", slotName, "button exists:", slotButton ~= nil, "icon exists:", equippedIcon ~= nil, "equippedItemId:", equippedItemId or "none")

		if equippedIcon then
			if equippedItemId then
				-- Извлекаем имя предмета из equippedItemId (убираем "_номер")
				local itemName = string.match(equippedItemId, "^(.+)_%d+$")
				-- Получаем иконку предмета по имени
				local itemIconId = itemName and allItemIcons[itemName] or "0"
				self.logger:info("InventoryUI", "Setting icon for slot", slotName, "item:", itemName, "icon:", itemIconId)
				equippedIcon.Image = itemIconId or ""
				slotButton.BackgroundColor3 = Color3.fromRGB(80, 80, 120) -- Выделяем занятые слоты
				slotButton.TextTransparency = 1 -- Полупрозрачный текст для занятых слотов
			else
				self.logger:info("InventoryUI", "Clearing slot", slotName)
				equippedIcon.Image = ""
				slotButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60) -- Пустые слоты
				slotButton.TextTransparency = 0 -- Обычная прозрачность для пустых слотов
			end
		else
			self.logger:warn("InventoryUI", "EquippedIcon not found for slot", slotName)
		end
	end
end

function InventoryUI:updateSlotsInfoLabel()
	if not self.slotsInfoLabel then
		return
	end

	local inventoryData = self.inventoryClientService:getInventoryData()
	if not inventoryData or not inventoryData.inventorySlots then
		self.slotsInfoLabel.Text = "Slots: 0/50"
		return
	end

	local usedSlots = 0
	for _, itemSlots in pairs(inventoryData.inventorySlots) do
		usedSlots = usedSlots + #itemSlots
	end

	local maxSlots = 50 -- Можно получить из InventoryEntity если понадобится
	local freeSlots = maxSlots - usedSlots

	self.slotsInfoLabel.Text = `Slots: {usedSlots}/{maxSlots} ({freeSlots} free)`
end

return InventoryUI
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>